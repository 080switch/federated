# Copyright 2018, The TensorFlow Federated Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Defines intrinsics for use in composing federated computations."""

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

from tensorflow_federated.python.core.impl import context_stack_impl
from tensorflow_federated.python.core.impl import intrinsic_factory


def federated_aggregate(value, zero, accumulate, merge, report):
  """Aggregates `value` from `CLIENTS` to `SERVER` using a multi-stage process.

  This generalized aggregation function admits multi-layered architectures that
  involve one or more intermediate stages to handle scalable aggregation across
  a very large number of participants.

  The aggregation process is defined as follows:

  * Clients are organized into groups. Within each group, a set of all the
    member constituents of `value` contributed by clients in the group are first
    reduced in a manner similar to `federated_reduce` using reduction operator
    `accumulate` with `zero` as the zero in the algebra. As described in the
    documentation for `federated_reduce`, if members of `value` are of type `T`,
    and `zero` (the result of reducing an empty set) is of type `U`, the
    reduction operator `accumulate` used at this stage should be of type
    `(<U,T> -> U)`. The result of this stage is a set of items of type `U`, one
    item for each group of clients.

  * Next, the `U`-typed items generated by the preceding stage are merged using
    the binary commutative associative operator `merge` of type `(<U,U> -> U)`.
    This can be interpreted as a `federated_reduce` using `merge` as the
    reduction operator, and the same `zero` in the algebra. The result of this
    stage is a single top-level `U` that emerges at the root of the hierarchy at
    the `SERVER`. Actual implementations may structure this step as cascade of
    multiple layers.

  * Finally, the `U`-typed result of the reduction performed in the preceding
    stage is projected into the result value using `report` as the mapping
    function (for example, if the structures being merged consist of counters,
    this final step might include computing their ratios).

  Args:
    value: A value of a TFF federated type placed at `CLIENTS` to aggregate.
    zero: The zero in the algebra of reduction operators, as described above.
    accumulate: The reduction operator to use in the first stage of the process.
      If `value` is of type `{T}@CLIENTS`, and `zero` is of type `U`, this
      operator should be of type `(<U,T> -> U)`.
    merge: The reduction operator to employ in the second stage of the process.
      Must be of type `(<U,U> -> U)`, where `U` is as defined above.
    report: The projection operator to use at the final stage of the process to
      compute the final resulrt of aggregation. If the indended result to be
      returned by `federated_aggregate` is of type `R@SERVER`, this operator
      must be of type `(U -> R)`.

  Returns:
    A representation on the `SERVER` of the result of aggregating `value` using
    the multi-stage process described above.

  Raises:
    TypeError: if the arguments are not of the types specified above.
  """
  factory = intrinsic_factory.IntrinsicFactory(context_stack_impl.context_stack)
  return factory.federated_aggregate(value, zero, accumulate, merge, report)


def federated_apply(func, arg):
  """Applies a given function to a federated value on the `SERVER`.

  Args:
    func: A function to apply to the member content of `arg` on the `SERVER`.
      The parameter of this function must be of the same type as the member
      constituent of `arg`.
    arg: A value of a TFF federated type placed at the `SERVER`, and with the
      `all_equal` bit set.

  Returns:
    A federated value on the `SERVER` that represents the result of applying
    `func` to the member constituent of `arg`.

  Raises:
    TypeError: if the arguments are not of the appropriates computation_types.
  """
  factory = intrinsic_factory.IntrinsicFactory(context_stack_impl.context_stack)
  return factory.federated_apply(func, arg)


# TODO(b/122071074): Consider renaming federated_mean to better match names
# in TensorFlow, Numpy, and Pandas.
def federated_average(value, weight=None):
  """Computes a `SERVER` average of `value` placed on `CLIENTS`.

  Args:
    value: The value to be averaged. Must be of a TFF federated type placed at
      `CLIENTS`. The value may be structured, e.g., its member constituents can
      be named tuples. The tensor types that the value is composed of must be
      floating-point or complex.
    weight: An optional weight, a TFF federated integer or floating-point tensor
      value, also placed at `CLIENTS`.

  Returns:
    A representation at the `SERVER` of an average of the member constituents
    of `value`, optionally weighted with `weight` if specified (otherwise, the
    member constituents contributed by all clients are equally weighted).

  Raises:
    TypeError: if `value` is not a federated TFF value placed at `CLIENTS`, or
      if `weight` is not a federated integer or a floating-point tensor with
      the matching placement.
  """
  factory = intrinsic_factory.IntrinsicFactory(context_stack_impl.context_stack)
  return factory.federated_average(value, weight)


def federated_broadcast(value):
  """Broadcasts a federated value from the `SERVER` to the `CLIENTS`.

  Args:
    value: A value of a TFF federated type placed at the `SERVER`, all members
      of which are equal (the `all_equal` property of the federated type of
      `value` is True).

  Returns:
    A representation of the result of broadcasting: a value of a TFF federated
    type placed at the `CLIENTS`, all members of which are equal.

  Raises:
    TypeError: if the argument is not a federated TFF value placed at the
      `SERVER`.
  """
  factory = intrinsic_factory.IntrinsicFactory(context_stack_impl.context_stack)
  return factory.federated_broadcast(value)


def federated_collect(value):
  """Materializes a federated value from `CLIENTS` as a `SERVER` sequence.

  Args:
    value: A value of a TFF federated type placed at the `CLIENTS`.

  Returns:
    A stream of the same type as the member constituents of `value` placed at
    the `SERVER`.

  Raises:
    TypeError: if the argument is not a federated TFF value placed at `CLIENTS`.
  """
  factory = intrinsic_factory.IntrinsicFactory(context_stack_impl.context_stack)
  return factory.federated_collect(value)


def federated_map(value, mapping_fn):
  """Maps a federated value on CLIENTS pointwise using a given mapping function.

  Args:
    value: A value of a TFF federated type placed at the `CLIENTS`, or a value
      that can be implicitly converted into a TFF federated type, e.g., by
      zipping.
    mapping_fn: A mapping function to apply pointwise to member constituents of
      `value` on each of the participants in `CLIENTS`. The parameter of this
      function must be of the same type as the member constituents of `value`.

  Returns:
    A federated value on `CLIENTS` that represents the result of mapping.

  Raises:
    TypeError: if the arguments are not of the appropriates computation_types.
  """
  factory = intrinsic_factory.IntrinsicFactory(context_stack_impl.context_stack)
  return factory.federated_map(value, mapping_fn)


def federated_reduce(value, zero, op):
  """Reduces `value` from `CLIENTS` to `SERVER` using a reduction operator `op`.

  This method reduces a set of member constituents of a `value` of federated
  type `T@CLIENTS` for some `T`, using a given `zero` in the algebra (i.e., the
  result of reducing an empty set) of some type `U`, and a reduction operator
  `op` with type signature `(<U,T> -> U)` that incorporates a single `T`-typed
  member constituent of `value` into the `U`-typed result of partial reduction.
  In the special case of `T` equal to `U`, this corresponds to the classical
  notion of reduction of a set using a commutative associative binary operator.
  The generalized reduction (with `T` not equal to `U`) requires that repeated
  application of `op` to reduce a set of `T` always yields the same `U`-typed
  result, regardless of the order in which elements of `T` are processed in the
  course of the reduction.

  Args:
    value: A value of a TFF federated type placed at the `CLIENTS`.
    zero: The result of reducing a value with no constituents.
    op: An operator with type signature `(<U,T> -> U)`, where `T` is the type of
      the constituents of `value` and `U` is the type of `zero` to be used in
      performing the reduction.

  Returns:
    A representation on the `SERVER` of the result of reducing the set of all
    member constituents of `value` using the operator `op` into a single item.

  Raises:
    TypeError: if the arguments are not of the types specified above.
  """
  factory = intrinsic_factory.IntrinsicFactory(context_stack_impl.context_stack)
  return factory.federated_reduce(value, zero, op)


def federated_sum(value):
  """Computes a sum at `SERVER` of a federated value placed on the `CLIENTS`.

  Args:
    value: A value of a TFF federated type placed at the `CLIENTS`.

  Returns:
    A representation of the sum of the member constituents of `value` placed
    on the `SERVER`.

  Raises:
    TypeError: if the argument is not a federated TFF value placed at `CLIENTS`.
  """
  factory = intrinsic_factory.IntrinsicFactory(context_stack_impl.context_stack)
  return factory.federated_sum(value)


def federated_value(value, placement):
  """Returns a federated value at `placement`, with `value` as the constituent.

  Args:
    value: A value of a non-federated TFF type to be placed.
    placement: The desired result placement (either `SERVER` or `CLIENTS`).

  Returns:
    A federated value with the given placement `placement`, and the member
    constituent `value` equal at all locations.

  Raises:
    TypeError: if the arguments are not of the appropriates computation_types.
  """
  factory = intrinsic_factory.IntrinsicFactory(context_stack_impl.context_stack)
  return factory.federated_value(value, placement)


def federated_zip(value):
  """Converts an N-tuple of federated values into a federated N-tuple value.

  Args:
    value: A value of a TFF named tuple type, the elements of which are
      federated values placed at the `CLIENTS`.

  Returns:
    A federated value placed at the `CLIENTS` in which every member component
    at the given client is a named tuple that consists of the corresponding
     member components of the elements of `value` residing at that client.

  Raises:
    TypeError: if the argument is not a named tuple of federated values placed
    at 'CLIENTS`.
  """
  factory = intrinsic_factory.IntrinsicFactory(context_stack_impl.context_stack)
  return factory.federated_zip(value)

# Copyright 2021, The TensorFlow Federated Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Execution context for single-aggregation computations."""

from tensorflow_federated.python.core.api import computation_base
from tensorflow_federated.python.core.impl.compiler import building_blocks
from tensorflow_federated.python.core.impl.compiler import tree_analysis
from tensorflow_federated.python.core.impl.types import computation_types
from tensorflow_federated.python.core.impl.types import placements
from tensorflow_federated.python.core.impl.types import type_analysis


class MergeTypeNotAssignableError(TypeError):
  pass


class UpToMergeTypeError(TypeError):
  pass


class AfterMergeStructureError(ValueError):
  pass


class MergeableCompForm:
  """A data class for computations containing a single logical aggregation.

  `MergeableCompForm` contains three member computations, `up_to_merge`
  and `merge`, and `after_merge`. A computation in `MergeableCompForm` is
  defined to be equivalent to invoking `up_to_merge` on subsets of
  `CLIENTS`-placed arguments in sequence, invoking `merge` on the stream of
  these results, and passing the resulting value to
  `after_merge`, in addition to the original argument to `up_to_merge`.
  `up_to_merge` should return a single `tff.SERVER`-placed value. We
  require that the original argument is passed as the first positional argument
  to `after_merge`, and the merged result as the second.
  Further, we require that computations in `MergeableCompForm` contain *no* AST
  nodes with signatures taking arguments at `tff.CLIENTS` and producing results
  at `tff.SERVER`.

  `MergeableCompForm` computations are often generated by aligning a computation
  containing a single logical aggregation on this aggregation, and splitting it
  along its merge boundary. That is, since `merge` can be invoked repeatedly
  without changing the results of the computation, a computation of the form:

  ```
  @tff.federated_computation(...)
  def single_aggregation(arg):
    result_at_clients = work(arg)
    agg_result = tff.federated_aggregate(
        result_at_clients, zero, accumulate, merge, report)
    return postprocess(arg, agg_result)
  ```

  can be represented as the `MergeableCompForm` triplet:
  ```
  @tff.federated_computation(tff.AbstractType('T'))
  def up_to_merge(arg):
    result_at_clients = work(arg)
    agg_result = tff.federated_aggregate(
        result_at_clients, accumulate_zero, accumulate, merge, identity_report)
    return agg_result

  @tff.federated_computation([up_to_merge.type_signature.result.member,
                              up_to_merge.type_signature.result.member])
  def merge(arg):
    return merge(arg[0], arg[1])

  @tff.federated_computation(
      tff.AbstractType('T'), tff.type_at_server(merge.type_signature.result))
  def after_merge(original_arg, merged_result):
    return postprocess(original_arg, merged_result)
  ```

  A fair amount of complexity can be hidden in `postprocess`; it could, for
  example, compute some value on clients based on the result of the aggregation.
  But the restriction that `after_merge` can contain no aggregations ensures
  that `after_merge` can also be executed in a subround fashion: a
  `tff.CLIENTS`-placed result can only depend on its own local state and the
  result of the aggregation, while a `tff.SERVER`-placed result can only depend
  on the result of the single aggregation or a `tff.SERVER`-placed value.
  """

  def __init__(self, *, up_to_merge: computation_base.Computation,
               merge: computation_base.Computation,
               after_merge: computation_base.Computation):
    if not (up_to_merge.type_signature.result.is_federated() and
            up_to_merge.type_signature.result.placement.is_server()):
      raise UpToMergeTypeError(
          'Expected `up_to_merge` to return a single `tff.SERVER`-placed '
          f'value; found return type {up_to_merge.type_signature.result}.')

    # TFF's StructType assignability relation ensures that an unnamed struct can
    # be assigned to any struct with names.
    expected_merge_param_type = computation_types.StructType([
        (None, up_to_merge.type_signature.result.member),
        (None, up_to_merge.type_signature.result.member)
    ])
    if not merge.type_signature.parameter.is_assignable_from(
        expected_merge_param_type):

      raise MergeTypeNotAssignableError(
          'Type mismatch checking `merge` type signature.\n' +
          computation_types.type_mismatch_error_message(
              merge.type_signature.parameter,
              expected_merge_param_type,
              computation_types.TypeRelation.ASSIGNABLE,
              second_is_expected=True))
    if not (merge.type_signature.parameter[0].is_assignable_from(
        merge.type_signature.result) and
            merge.type_signature.parameter[1].is_assignable_from(
                merge.type_signature.result)):
      raise MergeTypeNotAssignableError(
          'Expected `merge` to have result which is assignable to '
          'each element of its parameter tuple; found parameter '
          f'of type: \n{merge.type_signature.parameter}\nAnd result of type: \n'
          f'{merge.type_signature.result}')

    expected_after_merge_arg_type = computation_types.StructType([
        (None, up_to_merge.type_signature.parameter),
        (None, computation_types.at_server(merge.type_signature.result)),
    ])
    after_merge.type_signature.parameter.check_assignable_from(
        expected_after_merge_arg_type)

    def _federated_type_predicate(
        type_signature: computation_types.Type,
        placement: placements.PlacementLiteral) -> bool:
      return (type_signature.is_federated() and
              type_signature.placement == placement)

    def _moves_clients_to_server_predicate(
        intrinsic: building_blocks.Intrinsic):
      parameter_contains_clients_placement = type_analysis.contains(
          intrinsic.type_signature.parameter,
          lambda x: _federated_type_predicate(x, placements.CLIENTS))
      result_contains_server_placement = type_analysis.contains(
          intrinsic.type_signature.result,
          lambda x: _federated_type_predicate(x, placements.SERVER))
      return (parameter_contains_clients_placement and
              result_contains_server_placement)

    aggregations = set()

    def _aggregation_predicate(
        comp: building_blocks.ComputationBuildingBlock) -> bool:
      if not comp.is_intrinsic():
        return False
      if not comp.type_signature.is_function():
        return False
      if _moves_clients_to_server_predicate(comp):
        aggregations.add((comp.uri, comp.type_signature))
        return True
      return False

    if tree_analysis.contains(after_merge.to_building_block(),
                              _aggregation_predicate):
      formatted_aggregations = ', '.join(
          '{}: {}'.format(elem[0], elem[1]) for elem in aggregations)
      raise AfterMergeStructureError(
          'Expected `after_merge` to contain no intrinsics '
          'with signatures accepting values at clients and '
          'returning values at server. Found the following '
          f'aggregations: {formatted_aggregations}')

    self.up_to_merge = up_to_merge
    self.merge = merge
    self.after_merge = after_merge
